var L3 = require('L3');var spark = require('sparkCore');model.Cartridge.methods.manufacture = function(param) {	// param: username, assayID, quantity	var assay = ds.Assay(param.assayID);	var user = ds.User.find('username === :1', param.username);	var c, i;	if (assay && user) {		for (i = 0; i < param.quantity; i += 1) {			c = ds.Cartridge.createEntity();			c.manufacturedOn = new Date();			c.assay = assay;			c.practice = user.practice;			c.save();		}				return param.quantity;	}	else {		return 0;	}};model.Cartridge.methods.manufacture.scope = 'public';model.Cartridge.methods.register = function(param) {	// param: username, cartridgeID	var cartridge = ds.Cartridge(param.cartridgeID);	var user = ds.User.find('username === :1', param.username);	if (cartridge && user) {		cartridge.registeredOn = new Date();		cartridge.registeredBy = user;		cartridge.save();		return 1;	}	else {		return 0;	}};model.Cartridge.methods.register.scope = 'public';model.Cartridge.entityMethods.get_data_from_device = function() {	var cartridge, data, header, i, indx, num_readings, r_minus_b, reading, result = {}, test;		cartridge = this;	if (cartridge && cartridge.lock() && cartridge.test.lock()) {		result = spark.request_test_data_by_uuid(cartridge.test.device.sparkCoreID, cartridge.ID);		if(result.success) {			cartridge.rawData = result.value;			data = cartridge.rawData.split('\n');			indx = data.indexOf('99');			if (indx === -1) {				cartridge.unlock();				cartridge.test.unlock();				return;			}						indx += 1;			num_readings = 2 * parseInt(data[0].split('\t')[4]);			r_minus_b = 0;			for (i = indx; i < num_readings + indx; i += 1) {				reading = data[i].split('\t');				r_minus_b += (i % 2 ? -1 : 1) * (parseInt(reading[4]) - parseInt(reading[6]));			}			cartridge.result = r_minus_b / num_readings;			header = data[0].split('\t');			cartridge.startedOn = L3.string_to_datetime(header[1]);			cartridge.finishedOn = L3.string_to_datetime(header[2]);			cartridge.save();			cartridge.unlock();			cartridge.test.unlock();						cartridge.test.cartridges.orderBy('finishedOn desc').forEach(function(c, k) {				if (k === 0) {					c.failed = false;					if (c.test.lock()) {						c.test.startedOn = c.startedOn;						c.test.finishedOn = c.finishedOn;						c.test.percentComplete = 100;						c.test.status = 'Complete';						c.test.save();					}				}				else {					c.failed = true;				}			});			result.message = 'Cartridge ' + cartridge.ID + ' updated';		}	}	else {		result = {success: false, message: 'Cartridge not found or locked'};	}		return result;};model.Cartridge.entityMethods.get_data_from_device.scope = 'public';model.Cartridge.entityMethods.mark_as_failed = function(param) {	var cartridge, data, header, i, indx, num_readings, r_minus_b, reading, result = {}, test;		cartridge = this;	if (cartridge && cartridge.lock() && cartridge.test.lock()) {		cartridge.failed = true;		cartridge.save();		cartridge.test.status = 'Failed';		cartridge.test.save();	}};model.Cartridge.entityMethods.mark_as_failed.scope = 'public';