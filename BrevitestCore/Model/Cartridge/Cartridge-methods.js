var L3 = require('L3');var spark = require('sparkCore');model.Cartridge.methods.manufacture = function(param) {	// param: username, assayID, quantity	var assay = ds.Assay(param.assayID);	var user = ds.User.find('username === :1', param.username);	var c, i;	if (assay && user) {		for (i = 0; i < param.quantity; i += 1) {			c = ds.Cartridge.createEntity();			c.manufacturedOn = new Date();			c.assay = assay;			c.practice = user.practice;			c.save();		}				return param.quantity;	}	else {		return 0;	}};model.Cartridge.methods.manufacture.scope = 'public';model.Cartridge.methods.register = function(param) {	// param: username, cartridgeID	var cartridge = ds.Cartridge(param.cartridgeID);	var user = ds.User.find('username === :1', param.username);	if (cartridge && user) {		cartridge.registeredOn = new Date();		cartridge.registeredBy = user;		cartridge.save();		return 1;	}	else {		return 0;	}};model.Cartridge.methods.register.scope = 'public';model.Cartridge.methods.start_scan = function() {	var result = {};	var barcodeManager = new SharedWorker('Workers/ScanBarcode.js', 'BarcodeScanManager');	var thePort = barcodeManager.port;     //attach onmessage to port (MessagePort)	thePort.onmessage = function(event) {		var message = event.data;		var url;		//decide what the message is telling us to do		switch (message.type) {			case 'connected': 				url = 'zxing://scan/?ret=http://' + application.httpServer.ipAddress + ':' + application.httpServer.port + '/return_cartridgeID/' + message.uuid + escape('?val={CODE}');				result = { success: true, uuid: message.uuid, url: url };				exitWait();				break;			case 'error':				result = { success: false, message: 'Error while monitoring test' };				exitWait();				break;		}     }	wait();		return result; //return tmInfo to the browser};model.Cartridge.methods.start_scan.scope = 'public';model.Cartridge.methods.wait_for_scan_result = function(param) {	// param: uuid for scan worker	var result = {};	var barcodeManager = new SharedWorker('Workers/ScanBarcode.js', 'BarcodeScanManager');	var thePort = barcodeManager.port;     //attach onmessage to port (MessagePort)	thePort.onmessage = function(event) {		var message = event.data;		//decide what the message is telling us to do		switch (message.type) {			case 'connected':				thePort.postMessage({ type: 'redirect', uuidFrom: param.uuid, uuidTo: message.uuid });				break;			case 'send_cartridgeID':				result = { success: true, cartridgeID: message.cartridgeID };				exitWait();				break;			case 'error':				result = { success: false, message: 'Error while waiting for scan results' };				exitWait();  //stop waiting for the result				break;		}     }	wait(); //waits until a call to exitWait() in this thread	//at this point, this thread is about to end but the shared	//worker continues on	return result; //return tmInfo to the browser};model.Cartridge.methods.wait_for_scan_result.scope = 'public';model.Cartridge.entityMethods.get_data_from_device = function(param) {	// param: cartridgeID	var cartridge, data, header, i, indx, num_readings, r_minus_b, reading, result = {}, test;		cartridge = this;	if (cartridge && cartridge.lock() && cartridge.test.lock()) {		result = spark.request_test_data_by_uuid(cartridge.test.device.sparkCoreID, cartridge.ID);		if(result.success) {			cartridge.rawData = result.value;			data = cartridge.rawData.split('\n');			indx = data.indexOf('99');			if (indx === -1) {				cartridge.unlock();				cartridge.test.unlock();				return;			}						indx += 1;			num_readings = 2 * parseInt(data[0].split('\t')[4]);			r_minus_b = 0;			for (i = indx; i < num_readings + indx; i += 1) {				reading = data[i].split('\t');				r_minus_b += parseInt(reading[4]) - parseInt(reading[6]);			}			cartridge.result = r_minus_b / num_readings;			header = data[0].split('\t');			cartridge.startedOn = L3.string_to_datetime(header[1]);			cartridge.finishedOn = L3.string_to_datetime(header[2]);			cartridge.save();						cartridge.test.cartridges.orderBy('finishedOn desc').forEach(function(c, k) {				if (k === 0) {					c.failed = false;					c.test.startedOn = c.startedOn;					c.test.finishedOn = c.finishedOn;					c.test.percentComplete = 100;					c.test.status = 'Complete';					c.test.save();				}				else {					c.failed = true;				}			});			result.message = 'Cartridge ' + cartridge.ID + ' updated';			cartridge.unlock();			cartridge.test.unlock();		}	}	else {		result = {success: false, message: 'Cartridge not found or locked'};	}		return result;};model.Cartridge.entityMethods.get_data_from_device.scope = 'public';model.Cartridge.entityMethods.mark_as_failed = function(param) {	var cartridge, data, header, i, indx, num_readings, r_minus_b, reading, result = {}, test;		cartridge = this;	if (cartridge && cartridge.lock() && cartridge.test.lock()) {		cartridge.failed = true;		cartridge.save();		cartridge.test.status = 'Failed';		cartridge.test.save();	}};model.Cartridge.entityMethods.mark_as_failed.scope = 'public';