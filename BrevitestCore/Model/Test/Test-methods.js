var spark = require('sparkCore');model.Test.methods.start = function(param) {	// param: username, deviceID, cartridgeID	var test;	var result = {};	var cartridge = ds.Cartridge(param.cartridgeID);	var device = ds.Device(param.deviceID);	var user = ds.User.find('username === :1', param.username);		if (cartridge === null) {		result.success = false;		result.message = 'Cartridge entity not found';		result.cartridgeID = param.cartridgeID;		return result;	}		if (device === null) {		result.success = false;		result.message = 'Device entity not found';		result.deviceID = param.deviceID;		return result;	}		if (user === null) {		result.success = false;		result.message = 'User not found';		result.username = param.username;		return result;	}	else {		practice = user.practice;	}		if (device.practice.ID !== practice.ID || cartridge.practice.ID !== practice.ID) {		result.success = false;		result.message = 'Practice is not the same for user, device, and cartridge';		result.cartridgePracticeID = cartridge.practice.ID;		result.devicePracticeID = device.practice.ID;		result.userPracticeID = practice.ID;		return result;	}		result = model.Device.methods.checkSerialNumber({deviceID: device.ID});	if (!result.success) {		result.deviceID = device.ID;		return result;	}		result = spark.ready_to_run_assay(device.sparkCoreID);	if (result && (result.status === 200) && (result.response.return_value !== -1)) {		result.success = true;		test = ds.Test.createEntity();		test.assay = cartridge.assay;		test.device = device;		test.startedOn = new Date();		test.BCODE = cartridge.assay.BCODE;			}	else {		result.success = false;		result.message = 'Device not ready. Please initialize, load cartridge, and try again';	}		if (result.success) {		result = spark.run_test(device.sparkCoreID, test.ID, test.BCODE);		if (result.success) {			test.save();			cartridge.test = test;			cartridge.startedOn = test.startedOn;			cartridge.save();		}		else {			result.success = false;			result.message = 'Test failed to begin.';		}	}		return result;};model.Test.methods.start.scope = 'public';model.Test.methods.updateStatus = function() {	//  query the existing Shared Worker that is started up from the bootstrap JS	//  to obtain the time of the most recent backup	var tmRef = 0;	var theWorker = new SharedWorker("Workers/SparkCoreUpdate.js", "SparkCoreUpdateThread");	var thePort = theWorker.port; //MessagePort	var result = '';  //  variable is updated within the onmessage function()			thePort.onmessage = function(event) {		var message = event.data;		switch (message.type)		{			case 'connected':  //  initial connection to shared worker thread  	  			tmRef = message.ref;    			thePort.postMessage({type: 'report', ref: tmRef});  //  request last backup time    			break;			case 'update':  //  requested information received from SharedWorker           		thePort.postMessage({type: 'disconnect', ref: tmRef});  //  tell SharedWorker we're done    			exitWait();  //  allow function to complete past wait() statement    			break;			case 'error':  //  error message received				result = 'Error received from update shared worker process.';           		exitWait();    			break;		}	};		wait();//waits until a call to exitWait() in this thread	//allows to handle incoming messages on the onmessage	return result;				};model.Test.methods.updateStatus.scope = 'public';