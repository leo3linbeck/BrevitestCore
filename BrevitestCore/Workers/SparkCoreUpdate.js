var spark = require('sparkCore');var L3 = require('L3');function updateCores(cores) {	cores.forEach(function(core) {		var a, d, s;		if (core.connected) {			d = ds.Device.find('sparkCoreID === :1', core.id);			if (d) {				d.online = core.connected;				d.sparkName = core.name;				d.sparkLastHeard = core.last_heard;				d.save();			}						s = spark.get_status(core.id);			if (s.success) {				d.status = s.success ? s.value : 'Status unavailable';				d.save();			}						a = spark.test_running(core.id);			if (a.success) {				if (a.value) {					t = ds.Test.find('ID === :1', a.value);					if (t) {						t.status = s.success ? s.value : 'Status unavailable';					}					core.available = false;				}				else {					core.available = true;				}			}			else {				core.available = false;			}		}		else {			d = ds.Device.find('sparkCoreID === :1', core.id);			if (d) {				d.online = false;				d.status = 'Status unavailable';				d.save();			}			core.available = false;		}	});}function updateCartridge(cartridgeID, coreID) {	var data, header, i, indx, num_readings, r_minus_b, reading, result = {}, test, testCartridges;	var cartridge = ds.Cartridge(cartridgeID);		if (cartridge) {		result = spark.request_test_data_by_uuid(coreID, cartridgeID);		if(result.success) {			cartridge.rawData = result.value;			data = cartridge.rawData.split('\n');			indx = data.indexOf('99');			if (indx === -1) {				return;			}						indx += 1;			num_readings = 2 * parseInt(data[0].split('\t')[4]);			r_minus_b = 0;			for (i = indx; i < num_readings + indx; i += 1) {				reading = data[i].split('\t');				r_minus_b += parseInt(reading[4]) - parseInt(reading[6]);			}			cartridge.result = r_minus_b / num_readings;			header = data[0].split('\t');			cartridge.startedOn = L3.string_to_datetime(header[1]);			cartridge.finishedOn = L3.string_to_datetime(header[2]);			cartridge.save();						cartridge.test.cartridges.orderBy('finishedOn desc').forEach(function(c, k) {				if (k === 0) {					c.failed = false;					c.test.startedOn = c.startedOn;					c.test.finishedOn = c.finishedOn;					c.test.save();				}				else {					c.failed = true;				}			});			result.message = 'Cartridge ' + cartridgeID + ' updated';		}	}	else {		result = {success: false, message: 'Cartridge not found'};	}		return result;}onconnect = function onconnect (event) {	var message, thePort;		//for a shared worker you use the array ports and attach	//onmessage to ports[0];	thePort = event.ports[0];	uuidKey = generateUUID();     //each new connection will receive a unique ID	connections[uuidKey] = thePort;     //keep a reference to the port	thePort.onmessage = function(event) {		var result, fromPort;		message = event.data;         //same as dedicated worker		//the parent always passes its unique reference in message.ref		//so we know who we are talking to		fromPort = connections[message.ref];		if (fromPort) {			if (workerError != 0) {    //something went wrong so…				//tell the parent thread				fromPort.postMessage({type: 'error', errorCode: workerError });				close();     //and close			}			else {				switch (message.type) {					case 'check_test_status':						if (message.sparkCoreID) {							result = spark.test_running(message.sparkCoreID);							if (result.success && !result.value) {								fromPort.postMessage({ type: 'test_complete' });							}						}						break;					case 'status':						if (message.sparkCoreID) {							result = spark.get_status(message.sparkCoreID);							fromPort.postMessage({type: 'status', status: result.success ? result.value : null});						}						break;					case 'update_cartridge':						if (message.sparkCoreID && message.cartridgeID) {							result = updateCartridge(message.cartridgeID, message.sparkCoreID);						}						break;					case 'update_devices':						result = spark.get_spark_core_list();						if (result.success) {							result = updateCores(result.response);						}						break;					case 'disconnect':						//parent is disconnecting, so remove its reference						delete connections[message.ref];						break;				}			}		}		else {			console.log('Worker port not found');		}	}	thePort.postMessage({type: 'connected', ref: uuidKey});}var uuidKey = '';     // unique identifier of each connectionvar workerError = 0;     //error code set in doSomeWorkvar connections = {};     // ports (connections) to parent threads