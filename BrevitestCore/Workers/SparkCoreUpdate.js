var spark = require('sparkCore');var tmCount = 0;var tmLastUpdate = 'Awaiting first update ... ';var tmKey = 0;var tmError = 0;var tmConnections = [];             function updateOneTestStatus(test) {	var result = spark.getStatus(test.device.sparkCoreID);	console.log('Update status result', result);	if (result.success) {		test.status = result.deviceStatus;		switch (result.deviceStatus) {			case 'Running':				result = spark.getPercentComplete(test.device.sparkCoreID);				console.log('Update percent complete result', result);				if (result.success) {					test.percentComplete = result.percentComplete;				}				break;			case 'Complete':				test.percentComplete = 100;				break;						}		test.save();		}}function doUpdateStatus() {	var testsUnderway;		console.log('Updating status at ' + new Date());		try {	testsUnderway = ds.Test.query('startedOn !== null AND finishedOn === null');		if (testsUnderway.length > 0) {			testsUnderway.forEach(				function (e) {					updateOneTestStatus(e);				}			);		}	}	catch(e) {		tmError = e;	}}onconnect = function(msg){	var thePort = msg.ports[0];    	tmKey += 1;	tmConnections[tmKey] = thePort;	thePort.onmessage = function(event)    {        var message = event.data;        var fromPort = tmConnections[message.ref];        switch (message.type) {			case 'report':  //  parent asking for time of last backup				if (tmError!= 0) {					fromPort.postMessage({type: 'error', errorCode: tmError });					close();  //  shut down SharedWorker thread if error encountered				}                else {					fromPort.postMessage({type: 'update', count: tmCount, lastUpdate: tmLastUpdate});				}				break;			case 'disconnect':				tmConnections[message.ref] = null;				break;		}	};	thePort.postMessage({type: 'connected', ref: tmKey});} doUpdateStatus();  //  Initial update so that there is not a delay at server startup timesetInterval(doUpdateStatus, 2000) //  Perform update every 2 seconds//  Note that setInterval() does not initiate the first function call until after the specified interval passes