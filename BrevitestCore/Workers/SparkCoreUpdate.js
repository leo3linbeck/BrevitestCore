var spark = require('sparkCore');var L3 = require('L3');L3.updateCount = 0;             function updateOneCore(core) {	var a, d, s;		if (core.connected) {		d = ds.Device.find('sparkCoreID === :1', core.id);		if (d) {			d.online = core.connected;			d.sparkName = core.name;			d.sparkLastHeard = core.last_heard;			d.save();		}				s = spark.get_status(core.id);		if (s.success) {			d.status = s.success ? s.value : 'Status unavailable';			d.save();		}				a = spark.test_running(core.id);		if (a.success) {			if (a.value) {				t = ds.Test.find('ID === :1', a.value);				if (t) {					t.status = s.success ? s.value : 'Status unavailable';				}				core.available = false;			}			else {				core.available = true;			}		}		else {			core.available = false;		}	}	else {		d = ds.Device.find('sparkCoreID === :1', core.id);		if (d) {			d.online = false;			d.status = 'Status unavailable';			d.save();		}		core.available = false;	}}function processOneCartridge(cartridge, coreID) {	var data, header, i, indx, num_readings, r_minus_b, reading, result, test, testCartridges;	result = spark.request_test_data_by_uuid(coreID, cartridge.ID);	if(result.success) {		cartridge.rawData = result.value;		data = cartridge.rawData.split('\n');		indx = data.indexOf('99');		if (indx === -1) {			return;		}				indx += 1;		num_readings = 2 * parseInt(data[0].split('\t')[4]);		r_minus_b = 0;		for (i = indx; i < num_readings + indx; i += 1) {			reading = data[i].split('\t');			r_minus_b += parseInt(reading[4]) - parseInt(reading[6]);		}		cartridge.result = r_minus_b / num_readings;		header = data[0].split('\t');		cartridge.startedOn = L3.string_to_datetime(header[1]);		cartridge.finishedOn = L3.string_to_datetime(header[2]);		cartridge.save();				cartridge.test.cartridges.orderBy('finishedOn desc').forEach(function(c, k) {			if (k === 0) {				c.failed = false;				c.test.startedOn = c.startedOn;				c.test.finishedOn = c.finishedOn;				c.test.save();			}			else {				c.failed = true;			}		});	}}function updateOneCartridge(cartridge, cores) {	var core, data, i, result;		for (i = 0; i < cores.length; i += 1) {		core = cores[i];		if (core.connected && core.available && (core.id === cartridge.test.device.sparkCoreID)) { // grab test info			processOneCartridge(cartridge, core.id);		}	}}function doUpdateStatus(){	var cartridges, datetime;		L3.updateCount += 1;	datetime = new Date();	console.log('Update ' + L3.updateCount + ': ' + datetime.toString());	console.log('get_list_of_cores: ' + result);	var result = spark.get_list_of_cores();	if (result.success) {		result.response.forEach(updateOneCore);		cartridges = ds.Cartridge.query('startedOn !== null AND finishedOn === null');		cartridges.forEach(function (c) {			updateOneCartridge(c, result.response);		});	}	else {		console.log(L3.updateCount + ': Spark API not available on ' + dt.toString());	}} onconnect = function(msg){    var thePort = msg.ports[0];        console.log('In onconnect');        thePort.postMessage("OK");}console.log('Start of updating...');              doUpdateStatus();  //  Initial update so that there is not a delay at server startup time//L3.updateStatusInterval = setInterval(doUpdateStatus, 10000); //  Perform update every 2 minutes