var spark = require('sparkCore');var L3 = require('L3');function updateCores(cores) {	cores.forEach(function(core) {		var a, d, s;		if (core.connected) {			d = ds.Device.find('sparkCoreID === :1', core.id);			if (d) {				d.online = core.connected;				d.sparkName = core.name;				d.sparkLastHeard = core.last_heard;				d.save();			}						s = spark.get_status(core.id);			if (s.success) {				d.status = s.success ? s.value : 'Status unavailable';				d.save();			}						a = spark.test_running(core.id);			if (a.success) {				if (a.value) {					t = ds.Test.find('ID === :1', a.value);					if (t) {						t.status = s.success ? s.value : 'Status unavailable';					}					core.available = false;				}				else {					core.available = true;				}			}			else {				core.available = false;			}		}		else {			d = ds.Device.find('sparkCoreID === :1', core.id);			if (d) {				d.online = false;				d.status = 'Status unavailable';				d.save();			}			core.available = false;		}	});}function updateCartridge(cartridge, coreID) {	var data, header, i, indx, num_readings, r_minus_b, reading, result = {}, test, testCartridges;		if (cartridge) {		result = spark.request_test_data_by_uuid(coreID, cartridge.ID);		if(result.success) {			cartridge.rawData = result.value;			data = cartridge.rawData.split('\n');			indx = data.indexOf('99');			if (indx === -1) {				return;			}						indx += 1;			num_readings = 2 * parseInt(data[0].split('\t')[4]);			r_minus_b = 0;			for (i = indx; i < num_readings + indx; i += 1) {				reading = data[i].split('\t');				r_minus_b += parseInt(reading[4]) - parseInt(reading[6]);			}			cartridge.result = r_minus_b / num_readings;			header = data[0].split('\t');			cartridge.startedOn = L3.string_to_datetime(header[1]);			cartridge.finishedOn = L3.string_to_datetime(header[2]);			cartridge.save();						cartridge.test.cartridges.orderBy('finishedOn desc').forEach(function(c, k) {				if (k === 0) {					c.failed = false;					c.test.startedOn = c.startedOn;					c.test.finishedOn = c.finishedOn;					c.test.percentComplete = 100;					c.test.status = 'Complete';					c.test.save();				}				else {					c.failed = true;				}			});			result.message = 'Cartridge ' + cartridge.ID + ' updated';		}	}	else {		result = {success: false, message: 'Cartridge not found'};	}		return result;}function updateTestPercentComplete(test) {	var result = spark.get_test_percent_complete(test.device.sparkCoreID);	if (result.success) {		if (test.percentComplete === result.value) {			return false;		}		test.percentComplete = result.value;		test.save();	}	return true;}function cancelTest(cartridgeID) {	var cartridge = ds.Cartridge(cartridgeID);	if (cartridge) {		cartridge.test.status = 'Cancelled';		cartridge.test.save();	}}onconnect = function onconnect (event) {	var message, thePort, uuidKey;		//for a shared worker you use the array ports and attach	//onmessage to ports[0];	thePort = event.ports[0];	uuidKey = generateUUID();     //each new connection will receive a unique ID	connections[uuidKey] = thePort;     //keep a reference to the port	thePort.onmessage = function(event) {		var cartridge, device, fromPort, result;		message = event.data;         //same as dedicated worker		//the parent always passes its unique reference in message.ref		//so we know who we are talking to		fromPort = connections[message.ref];		if (fromPort) {			if (workerError != 0) {    //something went wrong so…				//tell the parent thread				fromPort.postMessage({type: 'error', errorCode: workerError });				close();     //and close			}			else {				switch (message.type) {					case 'check_test_status':						cartridge = ds.Cartridge(message.ref);						if (updateTestPercentComplete(cartridge.test)) {							if (cartridge.test.percentComplete === 100 && cartridge.finishedOn === null) { // ignores multiple calls								result = updateCartridge(cartridge, cartridge.test.device.sparkCoreID);								fromPort.postMessage({ type: 'test_complete', result: result });								delete connections[message.ref];							}						}						else {							fromPort.postMessage({type: 'error', message: 'Test progress stopped' });						}						break;					case 'redirect':						connections[message.cartridgeID] = connections[message.ref];						delete connections[message.ref];						break;					case 'cancel':						cancelTest(message.cartridgeID);						delete connections[message.ref];						break;					case 'disconnect':						//parent is disconnecting, so remove its reference						delete connections[message.ref];						break;				}			}		}		else {			console.log('Worker port not found');		}	}	thePort.postMessage({type: 'connected', ref: uuidKey});}var workerError = 0;     //error code set in doSomeWorkvar connections = {};     // ports (connections) to parent threads