var spark = require('sparkCore');var L3 = require('L3');function startDeviceDaemon(interval, timeout) {	console.log('Creating device daemon');	deviceDaemon = new SharedWorker('Workers/DeviceDaemon.js');	deviceDaemon.port.onmessage = function(event) {		console.log('Message received from device daemon');		var message = event.data;		switch (message.type) {			case 'connected':				deviceDaemon.port.postMessage({ type: 'start', interval: interval, timeout: timeout });				console.log('Device daemon connected');				exitWait();				break;		}	}	wait();}function startTestDaemon(interval, timeout) {	console.log('Creating test daemon');	testDaemon = new SharedWorker('Workers/TestDaemon.js');	testDaemon.port.onmessage = function(event) {		console.log('Message received from test daemon');		var message = event.data;		switch (message.type) {			case 'connected':				testDaemon.port.postMessage({ type: 'start', interval: interval, timeout: timeout });				console.log('Test daemon connected');				exitWait();				break;		}	}	wait();}function updateCores(cores) {	cores.forEach(function(core) {		var a, d, s;		if (core.connected) {			d = ds.Device.find('sparkCoreID === :1', core.id);			if (d) {				d.online = core.connected;				d.sparkName = core.name;				d.sparkLastHeard = core.last_heard;				d.save();			}						s = spark.get_status(core.id);			if (s.success) {				d.status = s.success ? s.value : 'Status unavailable';				d.save();			}						a = spark.test_running(core.id);			if (a.success) {				if (a.value) {					t = ds.Test.find('ID === :1', a.value);					if (t) {						t.status = s.success ? s.value : 'Status unavailable';					}					core.available = false;				}				else {					core.available = true;				}			}			else {				core.available = false;			}		}		else {			d = ds.Device.find('sparkCoreID === :1', core.id);			if (d) {				d.online = false;				d.status = 'Status unavailable';				d.save();			}			core.available = false;		}	});}function updateCartridge(cartridge) {	var data, header, i, indx, num_readings, r_minus_b, reading, result = {}, test, testCartridges;		if (cartridge) {		result = spark.request_test_data_by_uuid(cartridge.test.device.sparkCoreID, cartridge.ID);		if(result.success) {			cartridge.rawData = result.value;			data = cartridge.rawData.split('\n');			indx = data.indexOf('99');			if (indx === -1) {				return;			}						indx += 1;			num_readings = 2 * parseInt(data[0].split('\t')[4]);			r_minus_b = 0;			for (i = indx; i < num_readings + indx; i += 1) {				reading = data[i].split('\t');				r_minus_b += parseInt(reading[4]) - parseInt(reading[6]);			}			cartridge.result = r_minus_b / num_readings;			header = data[0].split('\t');			cartridge.startedOn = L3.string_to_datetime(header[1]);			cartridge.finishedOn = L3.string_to_datetime(header[2]);			cartridge.save();						cartridge.test.cartridges.orderBy('finishedOn desc').forEach(function(c, k) {				if (k === 0) {					c.failed = false;					c.test.startedOn = c.startedOn;					c.test.finishedOn = c.finishedOn;					c.test.percentComplete = 100;					c.test.status = 'Complete';					c.test.save();				}				else {					c.failed = true;				}			});			result.message = 'Cartridge ' + cartridge.ID + ' updated';		}	}	else {		result = {success: false, message: 'Cartridge not found'};	}		return result;}function updateTestPercentComplete(test) {	var result = spark.get_test_percent_complete(test.device.sparkCoreID);	if (result.success) {		test.percentComplete = result.value;		test.save();	}}function cancelTest(cartridgeID) {	var cartridge = ds.Cartridge(cartridgeID);	var result = spark.cancel_test(cartridge.test.device.sparkCoreID);	if (result.success) {		cartridge.test.status = 'Cancelled';		cartridge.test.save();	}	return result;}onconnect = function onconnect (event) {	var message, thePort, uuidKey;		//for a shared worker you use the array ports and attach	//onmessage to ports[0];	thePort = event.ports[0];	uuidKey = generateUUID();     //each new connection will receive a unique ID	connections[uuidKey] = thePort;     //keep a reference to the port	thePort.onmessage = function(event) {		var cartridge, device, fromPort, result;		message = event.data;         //same as dedicated worker		//the parent always passes its unique reference in message.ref		//so we know who we are talking to		fromPort = connections[message.ref];		if (fromPort) {			if (workerError != 0) {    //something went wrong so…				//tell the parent thread				fromPort.postMessage({type: 'error', errorCode: workerError });				close();     //and close			}			else {				switch (message.type) {					case 'check_test_status':						cartridge = ds.Cartridge(message.ref);						if (cartridge) {							if (cartridge.test.status === 'In progress') {								updateTestPercentComplete(cartridge.test);								if (cartridge.test.percentComplete === 100 && cartridge.finishedOn === null) { // ignores multiple calls									fromPort.postMessage({ type: 'test_complete', result: result });									delete connections[message.ref];								}							}							else {								delete connections[message.ref];							}						}						else {							fromPort.postMessage({type: 'error', message: 'Missing cartridge: ' + message.ref });							delete connections[message.ref];						}						break;					case 'switch_key_to_cartridgeID': // called after connect, switch connections key						connections[message.cartridgeID] = connections[message.ref];						delete connections[message.ref];						break;					case 'cancel':						result = cancelTest(message.ref);						result.message = 'Test cancelled';						fromPort.postMessage({ type: 'test_complete', result: result });						delete connections[message.ref];						break;					case 'disconnect':						delete connections[message.ref];						break;					case 'stop_device_daemon':						deviceDaemon.postMessage({ type: 'stop' });						break;					case 'stop_test_daemon':						testDaemon.postMessage({ type: 'stop' });						break;				}			}		}		else {			console.log('Worker port not found');		}	}	thePort.postMessage({type: 'connected', ref: uuidKey});	console.log('SparkCoreUpdate connected', connections);}var workerError = 0;     //error code set in doSomeWorkvar connections = {};     // ports (connections) to parent threadsvar deviceDaemon = null;var testDaemon = null;console.log('Initializing daemons');startDeviceDaemon(300000, 360000);startTestDaemon(300000, 360000);